<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>WebGL最終課題</title>
<link rel="icon" href="nkgw-marronnier.ico">
<link rel="stylesheet" href="css/styles.css">
<meta name="format-detection" content="telephone=no">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/99/three.min.js"></script>
</head>
<body>
<h1>WebGL最終課題</h1>
<h3>CIT　情報科学部　情報ネットワーク学科　3年　学生番号：1832099</h3>
<h4>使用したテクスチャ素材</h4>
<a href="" target="_blank" rel="noopener">->地球のテクスチャ</a>
<h4>提出課題の説明など</h4>
<details>
<summary>説明を読む</summary>
<br>
</details><br>
<details>
<summary>この課題のプログラム</summary>
<a href="https://github.com/nkgw-marronnier/WebGL-Three.js-/blob/master/tekitou1.html" target="blank" rel="noopener">->GitHub(nkgw-marronnier) [公開期間:2020/07/20~2020/07/30]</a><br>
</details>
<br>
<script>
var init = function() {
	var width = 960,
    height = 540;

	// レンダラーを作成
	var renderer = new THREE.WebGLRenderer();
	renderer.setSize(width, height);
	document.body.appendChild(renderer.domElement);

	// シーンを作成
	var scene = new THREE.Scene();

	// カメラを作成
	var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
  camera.position.set(0,0,8);

	//グループを作る
	var round_group = new THREE.Group();
	//3D空間にグループを追加する
	scene.add(round_group);

  //別グループを作る
  var teashi_group = new THREE.Group();
  scene.add(teashi_group);

  // 顔を作成
	var kaogeometry = new THREE.SphereGeometry(0.5, 32, 32);
	var kaomaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var kao = new THREE.Mesh( kaogeometry, kaomaterial );
	var radian = (Math.PI)*2;
	kao.position.set(-2.5* Math.cos(radian),0.7,-2.5*Math.sin(radian));
	round_group.add(kao);
	kao.scale.set(0.7,0.7,0.7);

	// 胴体を作成
	var doutaigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	var doutaimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var doutai = new THREE.Mesh( doutaigeometry, doutaimaterial );
	doutai.position.set(-2.5* Math.cos(radian),0,-2.5*Math.sin(radian));
	round_group.add(doutai);
	doutai.scale.set(0.7,1,0.7);

  // 左耳を作成
	var hidarimimigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	var hidarimimimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var hidarimimi = new THREE.Mesh( hidarimimigeometry, hidarimimimaterial );
	hidarimimi.position.set(-2.75* Math.cos(radian),1,-2.75*Math.sin(radian));
	round_group.add(hidarimimi);
	hidarimimi.scale.set(0.2,0.2,0.2);

  // 右耳を作成
	var migimimigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	var migimimimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var migimimi = new THREE.Mesh( migimimigeometry, migimimimaterial );
	migimimi.position.set(-2.25* Math.cos(radian),1,-2.25*Math.sin(radian));
	round_group.add(migimimi);
	migimimi.scale.set(0.2,0.2,0.2);

  //左手を作成
  var hidaritegeometry = new THREE.SphereGeometry(0.5, 32, 32);
	var hidaritematerial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var hidarite = new THREE.Mesh( hidaritegeometry, hidaritematerial );
	hidarite.position.set(-2.2* Math.cos(radian),0.3,-2.2*Math.sin(radian));
	teashi_group.add(hidarite);
	hidarite.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  hidarite.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis = new THREE.Vector3(10,5,10).normalize();
  //回転角度の指定(ラジアン)
  var angle = 4* Math.PI / 4;
  //クォータニオンオブジェクトの宣言
  var q = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q.setFromAxisAngle(axis,angle);
  //直方体オブジェクトのquaternionプロパティに代入
  hidarite.quaternion.copy(q);

  //右手を作成
  var migitegeometry = new THREE.SphereGeometry(0.5, 32, 32);
	var migitematerial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var migite = new THREE.Mesh( migitegeometry, migitematerial );
	migite.position.set(-2.8* Math.cos(radian),0.3,-2.8*Math.sin(radian));
	teashi_group.add(migite);
	migite.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  migite.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis2 = new THREE.Vector3(-10,-10,5).normalize();
  //回転角度の指定(ラジアン)
  var angle2 = 2* Math.PI / 4;
  //クォータニオンオブジェクトの宣言
  var q2 = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q2.setFromAxisAngle(axis2,angle2);
  //直方体オブジェクトのquaternionプロパティに代入
  migite.quaternion.copy(q2);

  //右足を作成
  var migiashigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	var migiashimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var migiashi = new THREE.Mesh( migiashigeometry, migiashimaterial );
	migiashi.position.set(-2.2* Math.cos(radian),-0.3,-2.2*Math.sin(radian));
	teashi_group.add(migiashi);
	migiashi.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  migiashi.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis3 = new THREE.Vector3(-10,-10,5).normalize();
  //回転角度の指定(ラジアン)
  var angle3 = 2* Math.PI / 4;
  //クォータニオンオブジェクトの宣言
  var q3 = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q3.setFromAxisAngle(axis3,angle3);
  //直方体オブジェクトのquaternionプロパティに代入
  migiashi.quaternion.copy(q3);

    //左足を作成
  var hidariashigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	var hidariashimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var hidariashi = new THREE.Mesh( hidariashigeometry, hidariashimaterial );
	hidariashi.position.set(-2.8* Math.cos(radian),-0.3,-2.8*Math.sin(radian));
	teashi_group.add(hidariashi);
	hidariashi.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  hidariashi.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis4 = new THREE.Vector3(-10,-5,-10).normalize();
  //回転角度の指定(ラジアン)
  var angle4 = 4* Math.PI / 4;
  //クォータニオンオブジェクトの宣言
  var q4 = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q4.setFromAxisAngle(axis4,angle4);
  //直方体オブジェクトのquaternionプロパティに代入
  hidariashi.quaternion.copy(q4);

  //手足グループをroundグループへ追加
  round_group.add(teashi_group);

  //平行光源
  var directionalLight = new THREE.DirectionalLight( 0xAAffff );
  directionalLight.position.set( 1, 1, 1 );
  //シーンに追加
  scene.add( directionalLight );

  //平行光源2
  var directionalLight2 = new THREE.DirectionalLight( 0xffAAff );
  directionalLight2.position.set( -1, 1, 1 );
  scene.add( directionalLight2 );

  var ue = 0;

	// 初回実行
	var update = function() {
		requestAnimationFrame(update);

	  // 熊を飛び跳ねさせる
		round_group.rotation.y -= 0.005;
    if(round_group.position.y >= 0.5){
      ue = 1;
    }
    if(round_group.position.y <= -0.5){
      ue = 0;
    }
    if(ue == 1){
      round_group.position.y -= 0.03;
    }
    if(ue == 0){
      round_group.position.y += 0.03;
    }
		renderer.render(scene, camera);
	};
	update();
}
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>