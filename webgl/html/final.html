<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <title>WebGL最終課題</title>
  <link rel="icon" href="/nkgw-marronnier.ico">
  <link rel="stylesheet" href="/css/styles.css">
  <meta name="format-detection" content="telephone=no">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/99/three.min.js"></script>
  <script src="/webgl/script/OrbitControls.js"></script>
  <script src="/webgl/script/VolumetricFire.js"></script>
</head>

<body>
  <h1>WebGL最終提出課題</h1>
  <h3>CIT　情報科学部　情報ネットワーク学科　3年　学生番号：1832099</h3>
  <div class="wrapper">
    <main>
      <canvas id="canvas"></canvas>
      <h4>使用したテクスチャ素材</h4>
      <a href="https://earthobservatory.nasa.gov/features/BlueMarble/BlueMarble_2002.php" target="_blank"
        rel="noopener">->地球のテクスチャ</a><br>
      <a href="https://www.beiz.jp" target="_blank" rel="noopener">->熊、水面のテクスチャ</a>
      <h4>提出課題の説明など</h4>
      <details>
        <summary>説明を読む</summary>
        全体のコード長は800行を超えるため、同じ説明をする部分などは割愛する。初めに画面(canvas)の領域を設定する。今回は960*540の16:9で設定した。次にclockのインスタンスを作成。THREE.Clock();がコンストラクタである。これはthree.js内のClockメソッド呼び出し、Clockは時間を追跡するもの。これはVolumetricFire.jsで炎を毎回レンダリングする際に用いる。レンダラーを作成して、HTMLファイル内のcanvasに描画するよう指定する。再帰関数のupdateメソッドでレンダラーの更新を行うことで、ページを閲覧している限り繰り返されることからcanvasに描画することができる。更にアンチエイリアスを有効にすることでオブジェクトの輪郭を滑らかに描画する。しかし、これによって計算量が増えて動作が重くなるので画面の解像度によってピクセル比率を変更するsetPixelRatioを設定した。次の行でレンダラーのサイズを描画領域のサイズに指定。オブジェクトに影を有効にするため、rendere.shadowMap.enabledをtrueにした。描画する際に必要なシーンを作成し、それを閲覧するカメラを作成する。最大描画距離は150である。またOrbitControls.jsでカメラ制御を追加。これによってマウススクロールで拡大縮小、左クリックで視点移動が可能になった。しかしこのままだとカメラ制御をする際に映像が滑らかにならないため、controls.enableDampingをtrueに。また、拡大縮小や視点移動の値を1にすることでより滑らかに制御できるようにした。controls.autoRotateで何も操作しなくてもそのページを閲覧しただけでカメラ視点が自動的に一周するようにもした。速度は0.5である。updateメソッドにカメラの制御更新を追加することで、ページを閲覧している限り繰り返されることからカメラ制御が実現できる。
        ここまではcanvasの設定であったがここからは描画する熊以外の図形のコードを大まかに説明する。はじめに円運動をさせるためにプリミティブ図形を格納するグループを５つ作成する。次にテクスチャを指定のファイルパスから読み込み、バンプマップを適用するテクスチャにはバンプマップを適用する。これにより光の当たり具合で平面なテクスチャでも立体的に見える。プリミティブ図形では基本的に球体を作成するTHREE.SphereGeometry();と立方体を作成するTHREE.BoxGeometry();、ドーナツを作成するTHREE.TorusGeometry();、地面や木のテクスチャを貼り付けるために平面の板を作成するPlaneGeometry();を宣言する。それぞれのメッシュにテクスチャとジオメトリを適用し、テクスチャが張り付けられたプリミティブ図形が完成する。球体の一つは中心座標(0,0,0)で自転をする地球であるため、地球のテクスチャを適用してクォータニオンでx軸をMath.PI/12だけ回転させた。本来ならば23.4度傾けたかったが知識不足で実現できず、30度の角度で妥協した。レンガのテクスチャとバンプマップを適用した立方体とドーナツはその地球を周回するため、２つのグループに分けて追加した。立方体は8個、ドーナツは10個、それぞれ360で割った座標に配置した。また、それだけだと面白みがないので1個ずつfor文で図形をグループのシーンに追加していく際にiの数だけx,y,z軸にiの値を代入して回転を加えた。それぞれ光源に照らされることによって後ろの図形に対して影を作るためplane.castShadowをtrueに。また同じようにこの図形にも他の図形の影を適用するためにplane.receiveShadowをtrueにした。地面は水面のテクスチャを適用し、バンプマップも適用した。レンガのテクスチャと同じ値でバンプマップを適用したら非常に気持ち悪くなったので0.01の値を適用した。また、y軸に対して垂直になるようにxを基準にMath.PI/-2だけ回転させた。更に図形の影を反映させるべく、plane.receiveShadowをtrueにした。2つのグループは全体で円運動をしており、再帰関数で永遠にレンダリングと座標移動を繰り返すことでアニメーションを実現している。地球はy軸がupdateメソッドを呼び出されるごとに0.01だけ増加する。立方体のグループはupdateメソッドを呼び出されるごとにx,ｙ軸共に0.005増加し、ドーナツは同じ値だけ減少する。これによって地球の自転運動、複雑な円運動を地球の周りで行う立方体とドーナツのアニメーションが実現できた。
        円運動し、上下運動もする熊の体はすべてが球体のプリミティブ図形からなっている。顔、耳はそのまま図形の大きさや座標を変換してグループに追加。手足はクォータニオンで回転させながら手足感を出した。理解しながら作ったというよりは正直、ものすごい数を打ってなんとかこの形にしたようなものなので詳しい解説はできない。ただ回転軸のベクトルを宣言し規格化。回転角度をラジアンで与えてクォータニオンオブジェクトの宣言を行う。次に回転軸と角度からクォータニオンを計算してそれを図形のプロパティに代入すると回転軸の角度を変えてプリミティブ図形が作成できることを学んだ[1]。もちろん、熊の体は全て影を受け取り、更に光源に照らされた場合には影を作る。その熊たちが格納されたグループを３つ作成することによって、地球を中心としてまるで盆踊りをするかのように回転する運動が出来上がっている。円運動は上の立方体とドーナツと同じようにグループを回転させている。上下運動は古典的で正しいくはないと思われるが、if文を用いて条件分岐を作り、それで指定した値以上に座標が行けば下へ値を増加させ、指定した値以下になれば上へ運動するようにしたものである。本来ならば単振動などを用いればよりしっかりとした上下運動ができると考えられるがそれを実装する知識を持ち合わせていなかったため、このようなコードで上下運動を実現した。
        次に地面の上にある炎や木について説明する。木はPlaneGeometryという平面な図形にアルファチャネルを含む木のテクスチャを貼り付けている。アルファチャネルとは画像の透過度を保持するものであり、この作品で参照される木のテクスチャの背景はすべて透過されるものとなっている。しかし、Three.js側のMaterialのところでtransparentをtrueにしなければ透過が有効化されないのでtrueにする。これにより、作品上では木の部分だけが見えて背景もしっかりなじんでいるように見える。また、カメラの角度を変えても木は向きを変えていつでも正面を向くようになっている。このことをビルボードという。ビルボードを実現するためにはsetFromRotationMatrixをupdateメソッド内に書き込む必要があり、これによってupdateが呼び出される毎にテクスチャが常にカメラの視線ベクトルに対して垂直になる[2]。炎はサンプルデータとして配布されたVolumetricFire.jsを用いて表現した。いじった場所といえばこの作品に合わせるために炎の大きさを調整したこと、テクスチャファイルの参照パスを変更したこと、炎が乱れることがあったのでjsファイル内でdepthWriteをfalseにしたくらいである。depthWriteは、面と面が重なって見えるときに陰に隠れた面を描画しないようにするものである[3]。炎が重なって見えるようにdepthWriteをfalseにした。炎のアニメーションは最初で宣言したclockで経過時間を求め、それを用いて炎を更新している。
        紙くずはパーティクルを複数用いて表現した。まず配置する範囲を最大描画距離の150に指定して個数は白色が5000個、青色、燈色、紫色が3000個とした。配置される座標はx,y,z軸共に配置する範囲150と乱数を掛け算して0.4を引いたもの。Pointの大きさは0.4とした。これによって、領域内に指定された数だけランダムに紙くずを表現するパーティクルを作成することができた。それをupdateメソッド内でそれぞれx,y軸が0.0001ずつ増加するようにすることでゆっくりと複雑に回転するパーティクルを表現できた。また、fogで領域内の10から150の距離の間に0x000000色の霧を作成した。0x000000の理由は宇宙空間であるため、黒に合わせた色を指定した。このfogによって遠くに行くにつれて紙くずがぼやかされていくようになった。カメラを縮小するとより幻想的なアニメーションを見ることができる。
        <br>
      </details><br>
      <details class="github">
        <summary>この課題のプログラム</summary>
        <a href="https://github.com/nkgw-marronnier/nkgw-marronnier.github.io/blob/master/webgl/js/final.js"
          target="_blank" rel="noopener" class="github">->GitHub(nkgw-marronnier) [公開期間:2020/07/20~2020/08/30]</a><br>
      </details><br>
    </main>
  </div>
  <footer>
    <p><a href="/index.html" class="foot">目次へ戻る</a><br>
      Chiba Institute of Technology NS B3 nkgw-marronnier(1832099) 2020</p>
  </footer>
  <script src="/webgl/script/stats.js"></script>
  <script src="/webgl/js/final.js"></script>
</body>

</html>