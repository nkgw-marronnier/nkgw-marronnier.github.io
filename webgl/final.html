<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>WebGL最終課題</title>
<link rel="icon" href="nkgw-marronnier.ico">
<link rel="stylesheet" href="css/styles.css">
<meta name="format-detection" content="telephone=no">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/99/three.min.js"></script>
<script src="/OrbitControls.js"></script>
</head>
<body>
<h1>WebGL最終提出課題</h1>
<h3>CIT　情報科学部　情報ネットワーク学科　3年　学生番号：1832099</h3>
<h4>使用したテクスチャ素材</h4>
<a href="https://earthobservatory.nasa.gov/features/BlueMarble/BlueMarble_2002.php" target="_blank" rel="noopener">->地球のテクスチャ</a><br>
<a href="https://www.beiz.jp/素材/革/" target="_blank" rel="noopener">->熊のテクスチャ</a>
<h4>提出課題の説明など</h4>
<details>
<summary>説明を読む</summary>
<br>
</details><br>
<details>
<summary>この課題のプログラム</summary>
<a href="https://github.com/nkgw-marronnier/WebGL-Three.js-/blob/master/tekitou1.html" target="blank" rel="noopener">->GitHub(nkgw-marronnier) [公開期間:2020/07/20~2020/07/30]</a><br>
</details>
<br>
<script>
var init = function() {
	var width = 960,
    height = 540;

	// レンダラーを作成
	var renderer = new THREE.WebGLRenderer();
	renderer.setSize(width, height);
	document.body.appendChild(renderer.domElement);

	// シーンを作成
	var scene = new THREE.Scene();

	// カメラを作成
	var camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
  camera.position.set(0,0,8);

  // カメラコントローラーを作成
  const controls = new THREE.OrbitControls(camera, canvas);

  // 滑らかにカメラコントローラーを制御する
  controls.enableDamping = true;
  controls.dampingFactor = 0.2;

  tick();

	//グループを作る
	var round_group = new THREE.Group();
	//3D空間にグループを追加する
	scene.add(round_group);

  var round2_group = new THREE.Group();
  scene.add(round2_group);

  var round3_group = new THREE.Group();
  scene.add(round3_group);

  // テクスチャー読み込み
	var textureLoader = new THREE.TextureLoader();
	var texture_earth = textureLoader.load("texture/earth.jpg");
	var mat_earth = new THREE.MeshLambertMaterial();
	mat_earth.map = texture_earth;
  var textureLoader = new THREE.TextureLoader();
	var texture = textureLoader.load("texture/stone.jpg");
	var mat = new THREE.MeshPhongMaterial();
	mat.map = texture;
  var textureLoader = new THREE.TextureLoader();
	var kawa1_texture = textureLoader.load("texture/kawa1.jpg");
	var kawa1_mat = new THREE.MeshPhongMaterial();
	kawa1_mat.map = kawa1_texture;
  var textureLoader = new THREE.TextureLoader();
	var kawa2_texture = textureLoader.load("texture/kawa2.jpg");
	var kawa2_mat = new THREE.MeshPhongMaterial();
	kawa2_mat.map = kawa2_texture;

  //バンプマップ読み込み
	var bump = textureLoader.load("texture/stone-bump.jpg");
	mat.bumpMap = bump;
	mat.bumpscale = 0.2;

  // 地球を作成
	var earthgeometry = new THREE.SphereGeometry(0.5, 32, 32);
	var earth = new THREE.Mesh(earthgeometry, mat_earth);
  earth.position.set( 0, 0, 0 );
  scene.add(earth);
  earth.scale.set(2.5,2.5,2.5);

  for(let i=0; i<10; i++){
  //立方体
    var GameCubeGeometry = new THREE.BoxGeometry( 1, 1, 1, 1, 1, 1);
    var GameCube = new THREE.Mesh( GameCubeGeometry, mat );
    var radian = i/8*(Math.PI)*2;
    GameCube.position.set(-3.5* Math.cos(radian),-0.3,-3.5*Math.sin(radian));
    round3_group.add( GameCube );
    GameCube.scale.set(0.5,0.5,0.5);
}

//外側
for(let i=0; i<10; i++){
  // 顔を作成
	var kaogeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var kaomaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var kao = new THREE.Mesh( kaogeometry, kawa1_mat );
  var radian = i/10*(Math.PI)*2;
	kao.position.set(-4.5* Math.cos(radian),0.7,-4.5*Math.sin(radian));
	round_group.add(kao);
	kao.scale.set(0.7,0.7,0.7);
}
for(let i=0; i<10; i++){
	// 胴体を作成
	var doutaigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var doutaimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var doutai = new THREE.Mesh( doutaigeometry, kawa1_mat );
  var radian = i/10*(Math.PI)*2;
	doutai.position.set(-4.5* Math.cos(radian),0,-4.5*Math.sin(radian));
	round_group.add(doutai);
	doutai.scale.set(0.7,1,0.7);
}
for(let i=0; i<10; i++){
  // 左耳を作成
	var hidarimimigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var hidarimimimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var hidarimimi = new THREE.Mesh( hidarimimigeometry, kawa1_mat );
  var radian = i/10*(Math.PI)*2;
	hidarimimi.position.set(-4.75* Math.cos(radian),1,-4.75*Math.sin(radian));
	round_group.add(hidarimimi);
	hidarimimi.scale.set(0.2,0.2,0.2);
}
for(let i=0; i<10; i++){
  // 右耳を作成
	var migimimigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var migimimimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var migimimi = new THREE.Mesh( migimimigeometry, kawa1_mat );
  var radian = i/10*(Math.PI)*2;
	migimimi.position.set(-4.25* Math.cos(radian),1,-4.25*Math.sin(radian));
	round_group.add(migimimi);
	migimimi.scale.set(0.2,0.2,0.2);
}
for(let i=0; i<10; i++){
  //左手を作成
  var hidaritegeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var hidaritematerial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var hidarite = new THREE.Mesh( hidaritegeometry, kawa1_mat );
  var radian = i/10*(Math.PI)*2;
	hidarite.position.set(-4.2* Math.cos(radian),0.3,-4.2*Math.sin(radian));
	round_group.add(hidarite);
	hidarite.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  hidarite.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis = new THREE.Vector3(10,5,10).normalize();
  //回転角度の指定(ラジアン)
  var angle = 4* Math.PI / 4;
  //クォータニオンオブジェクトの宣言
  var q = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q.setFromAxisAngle(axis,angle);
  //直方体オブジェクトのquaternionプロパティに代入
  hidarite.quaternion.copy(q);
}
for(let i=0; i<10; i++){
  //右手を作成
  var migitegeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var migitematerial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var migite = new THREE.Mesh( migitegeometry, kawa1_mat );
  var radian = i/10*(Math.PI)*2;
	migite.position.set(-4.8* Math.cos(radian),0.3,-4.8*Math.sin(radian));
	round_group.add(migite);
	migite.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  //migite.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis2 = new THREE.Vector3(-10,-10,5).normalize();
  //回転角度の指定(ラジアン)
  var angle2 = 2* Math.PI /4;
  //クォータニオンオブジェクトの宣言
  var q2 = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q2.setFromAxisAngle(axis2,angle2);
  //直方体オブジェクトのquaternionプロパティに代入
  migite.quaternion.copy(q2);
}
for(let i=0; i<10; i++){
  //右足を作成
  var migiashigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var migiashimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var migiashi = new THREE.Mesh( migiashigeometry, kawa1_mat );
  var radian = i/10*(Math.PI)*2;
	migiashi.position.set(-4.2* Math.cos(radian),-0.3,-4.2*Math.sin(radian));
	round_group.add(migiashi);
	migiashi.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  //migiashi.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis3 = new THREE.Vector3(-10,-10,5).normalize();
  //回転角度の指定(ラジアン)
  var angle3 = 2* Math.PI / 4;
  //クォータニオンオブジェクトの宣言
  var q3 = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q3.setFromAxisAngle(axis3,angle3);
  //直方体オブジェクトのquaternionプロパティに代入
  migiashi.quaternion.copy(q3);
}
for(let i=0; i<10; i++){
    //左足を作成
  var hidariashigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var hidariashimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var hidariashi = new THREE.Mesh( hidariashigeometry, kawa1_mat );
  var radian = i/10*(Math.PI)*2;
	hidariashi.position.set(-4.8* Math.cos(radian),-0.3,-4.8*Math.sin(radian));
	round_group.add(hidariashi);
	hidariashi.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  //hidariashi.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis4 = new THREE.Vector3(-10,-5,-10).normalize();
  //回転角度の指定(ラジアン)
  var angle4 = 4* Math.PI / 4;
  //クォータニオンオブジェクトの宣言
  var q4 = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q4.setFromAxisAngle(axis4,angle4);
  //直方体オブジェクトのquaternionプロパティに代入
  hidariashi.quaternion.copy(q4);
}

//内側
for(let i=0; i<8; i++){
  // 顔を作成
	var kaogeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var kaomaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var kao = new THREE.Mesh( kaogeometry, kawa2_mat );
  var radian = i/8*(Math.PI)*2;
	kao.position.set(-2.5* Math.cos(radian),0.7,-2.5*Math.sin(radian));
	round2_group.add(kao);
	kao.scale.set(0.7,0.7,0.7);
}
for(let i=0; i<8; i++){
	// 胴体を作成
	var doutaigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var doutaimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var doutai = new THREE.Mesh( doutaigeometry, kawa2_mat );
  var radian = i/8*(Math.PI)*2;
	doutai.position.set(-2.5* Math.cos(radian),0,-2.5*Math.sin(radian));
	round2_group.add(doutai);
	doutai.scale.set(0.7,1,0.7);
}
for(let i=0; i<8; i++){
  // 左耳を作成
	var hidarimimigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var hidarimimimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var hidarimimi = new THREE.Mesh( hidarimimigeometry, kawa2_mat );
  var radian = i/8*(Math.PI)*2;
	hidarimimi.position.set(-2.75* Math.cos(radian),1,-2.75*Math.sin(radian));
	round2_group.add(hidarimimi);
	hidarimimi.scale.set(0.2,0.2,0.2);
}
for(let i=0; i<8; i++){
  // 右耳を作成
	var migimimigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var migimimimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var migimimi = new THREE.Mesh( migimimigeometry, kawa2_mat );
  var radian = i/8*(Math.PI)*2;
	migimimi.position.set(-2.25* Math.cos(radian),1,-2.25*Math.sin(radian));
	round2_group.add(migimimi);
	migimimi.scale.set(0.2,0.2,0.2);
}
for(let i=0; i<8; i++){
  //左手を作成
  var hidaritegeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var hidaritematerial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var hidarite = new THREE.Mesh( hidaritegeometry, kawa2_mat );
  var radian = i/8*(Math.PI)*2;
	hidarite.position.set(-2.2* Math.cos(radian),0.3,-2.2*Math.sin(radian));
	round2_group.add(hidarite);
	hidarite.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  //hidarite.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis = new THREE.Vector3(10,5,10).normalize();
  //回転角度の指定(ラジアン)
  var angle = 4* Math.PI / 4;
  //クォータニオンオブジェクトの宣言
  var q = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q.setFromAxisAngle(axis,angle);
  //直方体オブジェクトのquaternionプロパティに代入
  hidarite.quaternion.copy(q);
}
for(let i=0; i<8; i++){
  //右手を作成
  var migitegeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var migitematerial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var migite = new THREE.Mesh( migitegeometry, kawa2_mat );
  var radian = i/8*(Math.PI)*2;
	migite.position.set(-2.8* Math.cos(radian),0.3,-2.8*Math.sin(radian));
	round2_group.add(migite);
	migite.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  //migite.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis2 = new THREE.Vector3(-10,-10,5).normalize();
  //回転角度の指定(ラジアン)
  var angle2 = 2* Math.PI /4;
  //クォータニオンオブジェクトの宣言
  var q2 = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q2.setFromAxisAngle(axis2,angle2);
  //直方体オブジェクトのquaternionプロパティに代入
  migite.quaternion.copy(q2);
}
for(let i=0; i<8; i++){
  //右足を作成
  var migiashigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var migiashimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var migiashi = new THREE.Mesh( migiashigeometry, kawa2_mat );
  var radian = i/8*(Math.PI)*2;
	migiashi.position.set(-2.2* Math.cos(radian),-0.3,-2.2*Math.sin(radian));
	round2_group.add(migiashi);
	migiashi.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  //migiashi.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis3 = new THREE.Vector3(-10,-10,5).normalize();
  //回転角度の指定(ラジアン)
  var angle3 = 2* Math.PI / 4;
  //クォータニオンオブジェクトの宣言
  var q3 = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q3.setFromAxisAngle(axis3,angle3);
  //直方体オブジェクトのquaternionプロパティに代入
  migiashi.quaternion.copy(q3);
}
for(let i=0; i<8; i++){
    //左足を作成
  var hidariashigeometry = new THREE.SphereGeometry(0.5, 32, 32);
	//var hidariashimaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, wireframe: true });
  var hidariashi = new THREE.Mesh( hidariashigeometry, kawa2_mat );
  var radian = i/8*(Math.PI)*2;
	hidariashi.position.set(-2.8* Math.cos(radian),-0.3,-2.8*Math.sin(radian));
	round2_group.add(hidariashi);
	hidariashi.scale.set(0.4,0.2,0.6);

  //クォータニオン利用の宣言
  //hidariashi.useQuaternion = true;
  //回転軸ベクトルの宣言・規格化
  var axis4 = new THREE.Vector3(-10,-5,-10).normalize();
  //回転角度の指定(ラジアン)
  var angle4 = 4* Math.PI / 4;
  //クォータニオンオブジェクトの宣言
  var q4 = new THREE.Quaternion();
  //回転軸と角度からクォータニオンを計算
  q4.setFromAxisAngle(axis4,angle4);
  //直方体オブジェクトのquaternionプロパティに代入
  hidariashi.quaternion.copy(q4);
}

  //平行光源
  var directionalLight = new THREE.DirectionalLight( 0xffffff );
  directionalLight.position.set( 1, 1, 1 );
  //シーンに追加
  scene.add( directionalLight );

  //平行光源2
  var directionalLight2 = new THREE.DirectionalLight( 0xffffff );
  directionalLight2.position.set( -1, 1, 1 );
  scene.add( directionalLight2 );

  	//星空1(白色)を作成
	var stargeometry = new THREE.Geometry();
	// 配置する範囲
	var SIZE = 1000;
	// 配置する個数
	var LENGTH = 5000;
	for (let i = 0; i < LENGTH; i++) {
	stargeometry.vertices.push(new THREE.Vector3(
		SIZE * (Math.random() - 0.5),
		SIZE * (Math.random() - 0.5),
		SIZE * (Math.random() - 0.5),));
	}
	var starmaterial = new THREE.PointsMaterial({
	size: 0.6,color: 0xF0FFFF,});
	var starmesh = new THREE.Points(stargeometry, starmaterial);
	scene.add(starmesh)

	//星空2(青色)を作成
	var stargeometry2 = new THREE.Geometry();
	// 配置する範囲
	var SIZE = 1000;
	// 配置する個数
	var LENGTH = 1000;
	for (let i = 0; i < LENGTH; i++) {
	stargeometry2.vertices.push(new THREE.Vector3(
		SIZE * (Math.random() - 0.5),
		SIZE * (Math.random() - 0.5),
		SIZE * (Math.random() - 0.5),));
	}
	var starmaterial2 = new THREE.PointsMaterial({
	size: 0.6,color: 0x00FFFF,});
	var starmesh2 = new THREE.Points(stargeometry2, starmaterial2);
	scene.add(starmesh2)

	//星空3(燈色)を作成
	var stargeometry3 = new THREE.Geometry();
	// 配置する範囲
	var SIZE = 1000;
	// 配置する個数
	var LENGTH = 1000;
	for (let i = 0; i < LENGTH; i++) {
	stargeometry3.vertices.push(new THREE.Vector3(
		SIZE * (Math.random() - 0.5),
		SIZE * (Math.random() - 0.5),
		SIZE * (Math.random() - 0.5),));
	}
	var starmaterial3 = new THREE.PointsMaterial({
	size: 0.6,color: 0xFF8C00,});
	var starmesh3 = new THREE.Points(stargeometry3, starmaterial3);
	scene.add(starmesh3)

	//星空4(紫色)を作成
	var stargeometry4 = new THREE.Geometry();
	// 配置する範囲
	var SIZE = 1000;
	// 配置する個数
	var LENGTH = 1000;
	for (let i = 0; i < LENGTH; i++) {
	stargeometry4.vertices.push(new THREE.Vector3(
		SIZE * (Math.random() - 0.5),
		SIZE * (Math.random() - 0.5),
		SIZE * (Math.random() - 0.5),));
	}
	var starmaterial4 = new THREE.PointsMaterial({
	size: 0.6,color: 0xFF00FF,});
	var starmesh4 = new THREE.Points(stargeometry4, starmaterial4);
	scene.add(starmesh4)

  // 毎フレーム時に実行されるループイベントです
function tick() {
  // カメラコントローラーを更新
  controls.update();

  // レンダリング
  renderer.render(scene, camera);

  requestAnimationFrame(tick);
}

  var ue = 0;
  var ue2 = 1;

	// 初回実行
	var update = function() {
		requestAnimationFrame(update);

    earth.rotation.y += 0.01;

	  // 熊を飛び跳ねさせる
		round_group.rotation.y -= 0.005;
    round2_group.rotation.y += 0.005;
    round3_group.rotation.y += 0.005;
    round3_group.rotation.x += 0.005;
    if(round_group.position.y >= 0.5){
      ue = 1;
    }
    if(round_group.position.y <= -0.5){
      ue = 0;
    }
    if(ue == 1){
      round_group.position.y -= 0.03;
    }
    if(ue == 0){
      round_group.position.y += 0.03;
    }
    if(round2_group.position.y >= 0.5){
      ue2 = 1;
    }
    if(round2_group.position.y <= -0.5){
      ue2 = 0;
    }
    if(ue2 == 1){
      round2_group.position.y -= 0.03;
    }
    if(ue2 == 0){
      round2_group.position.y += 0.03;
    }

    //星空を回転させる
		starmesh.rotation.y += 0.0001;
		starmesh.rotation.x += 0.0001;
		starmesh2.rotation.y += 0.0001;
		starmesh2.rotation.x += 0.0001;
		starmesh3.rotation.y += 0.0001;
		starmesh3.rotation.x += 0.0001;
		starmesh4.rotation.y += 0.0001;
		starmesh4.rotation.x += 0.0001;

		renderer.render(scene, camera);
	};
	update();
}
window.addEventListener('DOMContentLoaded', init);
</script>
</body>
</html>